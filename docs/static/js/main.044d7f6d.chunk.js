(this.webpackJsonpapp=this.webpackJsonpapp||[]).push([[0],{31:function(e,n,o){e.exports=o(43)},43:function(e,n,o){"use strict";o.r(n);var r=o(0),t=o.n(r),a=o(21),i=o.n(a),l=o(18),c=o.n(l),s=o(22),u=o(1),f=o(6),v=o(23),g=o(10),d=o(7),m=o(8),p=o(19),h=o(16),C=o(3),b=o(25),L=o.n(b),x=o(26),B=o(2);function y(){var e=Object(p.a)(["\n  width: 100vw;\n  height: 100vh;\n  background-color: #000000;\n"]);return y=function(){return e},e}function N(){var e=Object(p.a)(["\n  ","\n  *, *::after, *::before {\n    box-sizing: border-box;\n    -moz-osx-font-smoothing: grayscale;\n    -webkit-font-smoothing: antialiased;\n    font-smoothing: antialiased;\n  }\n"]);return N=function(){return e},e}var O=Object(C.css)(N(),L.a),V=Object(C.css)(y()),j={uniforms:{baseColor:{type:"v3",value:[1,1,1]},emissiveColor:{type:"v3",value:[0,0,0]},specular:{type:"f",value:1},metallic:{type:"f",value:0},roughness:{type:"f",value:.1},ambientLight:{type:"v3",value:[.1,.1,.1]},directionalLightColor:{type:"v3",value:[1,1,1]},directionalLightDirection:{type:"v3",value:[-1,1,1]},directionalLightIntensity:{type:"f",value:3.141592653589793},envMap:{type:"t",value:null}},vertexShader:"\n    varying vec2 vUv;\n    varying vec3 vWorldNormal;\n    varying vec3 vWorldPosition;\n\n    #include <common>\n\n    void main() {\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\n      vUv = uv;\n      vWorldNormal = normalMatrix * normal;\n      vWorldPosition = worldPosition.xyz;\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    varying vec3 vWorldNormal;\n    // uniform vec3 ambientLight;\n    uniform vec3 directionalLightColor;\n    uniform vec3 directionalLightDirection;\n    uniform float directionalLightIntensity;\n    uniform vec3 baseColor;\n    uniform vec3 emissiveColor;\n    uniform float specular;\n    uniform float metallic;\n    uniform float roughness;\n    uniform samplerCube envMap;\n\n    #include <common>\n\n    uniform struct FGBuffer {\n      vec3 diffuseColor;\n      vec3 subsurfaceColor;\n      vec3 specularColor;\n      vec3 emissiveColor;\n      float roughness;\n      float AO;\n    };\n\n    uniform struct FLighting {\n      vec3 diffuse;\n      vec3 specular;\n      float transmission;\n    };\n\n    uniform struct BxDFContext {\n      float NoV;\n      float NoL;\n      float VoL;\n      float NoH;\n      float VoH;\n    };\n\n    float rcp(float src) {\n      return 1.0 / src;\n    }\n\n    float pow5(float src) {\n      return pow4(src) * src;\n    }\n\n    void BxDFContext_Init(inout BxDFContext Context, vec3 N, vec3 V, vec3 L) {\n      Context.NoL = dot(N, L);\n      Context.NoV = dot(N, V);\n      Context.VoL = dot(V, L);\n      float InvLenH = inversesqrt(2.0 + 2.0 * Context.VoL);\n      Context.NoH = saturate((Context.NoL + Context.NoV) * InvLenH);\n      Context.VoH = saturate(InvLenH + InvLenH * Context.VoL);\n    }\n\n    vec3 Diffuse_Lambert(vec3 diffuseColor) {\n      return diffuseColor * (1.0 / PI);\n    }\n\n    float D_GGX(float a2, float NoH) {\n      float d = (NoH * a2 - NoH) * NoH + 1.0;\n      return a2 / ( PI * d * d );\n    }\n\n    float Vis_SmithJointApprox(float a2, float NoV, float NoL) {\n      float a = sqrt(a2);\n      float Vis_SmithV = NoL * (NoV * (1.0 - a) + a);\n      float Vis_SmithL = NoV * (NoL * (1.0 - a) + a);\n      return 0.5 * rcp(Vis_SmithV + Vis_SmithL);\n    }\n\n    vec3 F_Schlick(vec3 specularColor, float VoH) {\n      float Fc = pow5(1.0 - VoH);\n      return saturate(50.0 * specularColor.g) * Fc + (1.0 - Fc) * specularColor;\n    }\n\n    vec3 specularGGX(float roughness, vec3 specularColor, BxDFContext Context, float NoL) {\n      float a2 = pow4(roughness);\n      // float energy = energyNormalization(a2, Context.VoH, \n      float energy = 1.0;\n\n      // microfacet specular\n      float D = D_GGX(a2, Context.NoH) * energy;\n      float Vis = Vis_SmithJointApprox(a2, Context.NoV, NoL);\n      vec3 F = F_Schlick(specularColor, Context.VoH);\n      return (D * Vis) * F;\n    }\n\n    vec3 computeF0(float specular, vec3 baseColor, float metallic) {\n      return mix(vec3(0.08 * specular), baseColor, metallic);\n    }\n\n    FLighting defaultLitBxDF(FGBuffer GBuffer, vec3 N, vec3 V, vec3 L, float NoL) {\n      BxDFContext Context;\n      BxDFContext_Init(Context, N, V, L);\n      Context.NoV = saturate(abs(Context.NoV) + 1e-5);\n\n      vec3 falloffColor = vec3(1.0);\n      float falloff = 1.0;\n\n      FLighting Lighting;\n      Lighting.diffuse = falloffColor * (falloff * NoL) * Diffuse_Lambert(GBuffer.diffuseColor);\n      Lighting.specular = falloffColor * (falloff * NoL) * specularGGX(GBuffer.roughness, GBuffer.specularColor, Context, NoL);\n      Lighting.transmission = 0.0;\n      return Lighting;\n    }\n\n    vec3 getForwardDirectionalLight(FGBuffer GBuffer) {\n      vec3 cameraDir = -normalize(vWorldPosition - cameraPosition);\n      vec3 V = cameraDir;\n      vec3 N = vWorldNormal;\n      vec3 L = normalize(directionalLightDirection);\n      float NoL = saturate(dot(N, L));\n      FLighting Lighting = defaultLitBxDF(GBuffer, N, V, L, NoL);\n\n      vec3 lightColor = directionalLightColor * directionalLightIntensity;\n      vec3 totalLight = vec3(0.0);\n      totalLight += (Lighting.diffuse + Lighting.specular) * lightColor;\n      totalLight += (Lighting.transmission) * lightColor;\n      return totalLight;\n    }\n\n    vec3 envBRDFApprox(vec3 specularColor, float roughness, float NoV) {\n      const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n      const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n      vec4 r = roughness * c0 + c1;\n      float a004 = min(r.x * r.x, exp2(-0.28 * NoV)) * r.x + r.y;\n      vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n      AB.y *= saturate(50.0 * specularColor.g);\n      return specularColor * AB.x + AB.y;\n    }\n\n    vec3 getEnvColor(float roughness, vec3 specularColor, float indirectIrradiance) {\n      vec3 N = vWorldNormal;\n      vec3 V = -normalize(vWorldPosition - cameraPosition);\n\n      vec3 rayDirection = 2.0 * dot(V, N) * N - V;\n      float NoV = saturate(dot(N, V));\n\n      vec4 imageBasedReflections = vec4(0, 0, 0, 1);\n      vec2 compositedAverageBrightness = vec2(0, 1);\n      vec4 sampledColor = textureCube(envMap, rayDirection);\n      imageBasedReflections = vec4(sampledColor.rgb, 1.0 - sampledColor.a);\n      imageBasedReflections.rgb *= mix(1.0, indirectIrradiance, roughness);\n      imageBasedReflections.rgb += imageBasedReflections.a * 0.0;\n      vec3 specularIBL = imageBasedReflections.rgb;\n\n      vec3 specularBounce = 0.45 * specularColor * indirectIrradiance;\n      specularIBL.rgb = mix(specularIBL.rgb, specularBounce, 0.0);\n      specularColor = envBRDFApprox(specularColor, roughness, NoV);\n      return specularIBL.rgb * specularColor;\n    }\n\n    vec3 AOMultiBounce(vec3 color, float AO) {\n      vec3 a = 2.0404 * color - 0.3324;\n      vec3 b = -4.7951 * color + 0.6417;\n      vec3 c = 2.7552 * color + 0.6903;\n      return max(vec3(AO), ((AO * a + b) * AO + c) * AO);\n    }\n\n    void main() {\n      FGBuffer GBuffer;\n      GBuffer.diffuseColor = baseColor - baseColor * metallic;\n      GBuffer.subsurfaceColor = vec3(0.0);\n      GBuffer.specularColor = computeF0(specular, baseColor, metallic);\n      GBuffer.emissiveColor = emissiveColor;\n      GBuffer.roughness = roughness;\n\n      float materialAO = 1.0;\n      // GBuffer.AO = AOMultiBounce(Luminance(GBuffer.specularColor), materialAO).g;\n\n      vec3 diffuseDir = vWorldNormal;\n      vec3 diffuseColorForIndirect = GBuffer.diffuseColor;\n      vec3 diffuseIndirectLighting = vec3(0.0);\n      float indirectIrradiance = 0.0;\n      float indirectOcclusion = 1.0;\n      diffuseIndirectLighting *= indirectOcclusion;\n      indirectIrradiance *= indirectOcclusion;\n\n      vec3 diffuseColor = (diffuseIndirectLighting * diffuseColorForIndirect) * AOMultiBounce(baseColor, materialAO);\n      vec3 emissive = GBuffer.emissiveColor;\n      vec3 lightColor = getForwardDirectionalLight(GBuffer);\n      vec3 envColor = getEnvColor(GBuffer.roughness, GBuffer.specularColor, indirectIrradiance) * indirectOcclusion * AOMultiBounce(GBuffer.specularColor, materialAO);\n      vec4 fogging = vec4(0, 0, 0, 1);\n\n      // gl_FragColor = vec4(envColor, 1.0);\n      // return;\n\n      vec3 color = vec3(0.0);\n      color += lightColor;\n      color += envColor;\n      color += diffuseColor;\n      color += emissive;\n      color = color * fogging.a + fogging.rgb;\n\n      gl_FragColor = vec4(color, 1.0);\n    }\n  "};function F(e){var n=e.uniforms,o=function(){var e="/textures/bridge/",n=[e+"posx.jpg",e+"negx.jpg",e+"posy.jpg",e+"negy.jpg",e+"posz.jpg",e+"negz.jpg"],o=(new B.CubeTextureLoader).load(n);return o.format=B.RGBFormat,o.mapping=B.CubeReflectionMapping,o.encoding=B.sRGBEncoding,o}(),r=function(e){return Object.assign(function(e){return Object.assign({},j.uniforms,e)}(e),{metallic:{type:"f",value:1},roughness:{type:"f",value:.65},envMap:{type:"t",value:o}})},a=[];Object(h.b)((function(e){var o=!0,r=!1,t=void 0;try{for(var i,l=a[Symbol.iterator]();!(o=(i=l.next()).done);o=!0){i.value.uniforms.roughness.value=n.metallic.roughness}}catch(c){r=!0,t=c}finally{try{o||null==l.return||l.return()}finally{if(r)throw t}}}));for(var i=new B.SphereBufferGeometry(1,64,64),l={Iron:{baseColor:{type:"v3",value:[.56,.57,.58]}},Silver:{baseColor:{type:"v3",value:[.972,.96,.915]}},Aluminum:{baseColor:{type:"v3",value:[.913,.921,.925]}},Gold:{baseColor:{type:"v3",value:[1,.766,.336]}},Copper:{baseColor:{type:"v3",value:[.955,.637,.538]}},Chromium:{baseColor:{type:"v3",value:[.55,.556,.554]}},Nickel:{baseColor:{type:"v3",value:[.66,.609,.526]}},Titanium:{baseColor:{type:"v3",value:[.542,.497,.449]}},Cobalt:{baseColor:{type:"v3",value:[.662,.655,.634]}},Platinum:{baseColor:{type:"v3",value:[.672,.637,.585]}}},c=[],s=Object.keys(l),u=s.length,f=0;f<u;f++){var v=r(l[s[f]]),g=2.1*f-2.1*(u-1)*.5,d=new B.ShaderMaterial({vertexShader:j.vertexShader,fragmentShader:j.fragmentShader,uniforms:v});a.push(d),c.push(Object(C.jsx)("mesh",{receiveShadow:!0,castShadow:!0,position:[g,0,0],geometry:i,material:d}))}var m=B.ShaderLib.cube;return Object(C.jsx)(t.a.Fragment,null,c&&Object(C.jsx)(t.a.Fragment,null," ",c," "),Object(C.jsx)("mesh",null,Object(C.jsx)("sphereBufferGeometry",{attach:"geometry",args:[400,128,128]}),Object(C.jsx)("shaderMaterial",{attach:"material",args:[m],envMap:o,side:B.BackSide})))}var G=function(e){function n(e){var o;Object(f.a)(this,n),(o=Object(g.a)(this,Object(d.a)(n).call(this,e))).state={shaderModel:"UE4_BRDF"};var r=new x.GUI;return o.uniforms=Object(u.a)({baseColor:[255,255,255],emissiveColor:[0,0,0],specular:0,metallic:0,roughness:1,directionalLightColor:[255,255,255],directionalLightIntensity:Math.PI},"metallic",{roughness:.6}),r.addFolder("Shading Model").add(o.state,"shaderModel",["UE4_BRDF","LambertShader"]).name("Shader Model").onChange((function(e){})),r.addFolder("Metallic Parameter").add(o.uniforms.metallic,"roughness",0,1).name("Roughness"),o}return Object(m.a)(n,e),Object(v.a)(n,[{key:"componentDidMount",value:function(){var e=Object(s.a)(c.a.mark((function e(){return c.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"render",value:function(){return Object(C.jsx)("div",{css:V},Object(C.jsx)(C.Global,{styles:O}),Object(C.jsx)(h.a,{camera:{position:[0,1,13]}},Object(C.jsx)(F,{uniforms:this.uniforms})))}}]),n}(t.a.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));i.a.render(t.a.createElement(G,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}},[[31,1,2]]]);